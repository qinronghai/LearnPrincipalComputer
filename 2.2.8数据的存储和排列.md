##  大小端模式

对于一个由2个字节组成的16位整数，在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)中存储这两个字节有两种方法：

1. 一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；
2. 另一种方法是将高序字节存储在起始地址，这称为大端(big-endian)字节序。

![image.png](https://pic.rmb.bdstatic.com/bjh/02d62362fa0b4ed53e4579702f19feb8.jpeg)

##  边界对齐

一句话：K字节大小的数据必须要存储在K的整数倍的地址上
例如一个存储字长为32位的机器，现来详述一下依次存入一个int,short,double,char,short类型的数据的过程。假定int ,short,double ,char分别为4，2，8，1字节。那么它们分别占据字、半字、双字、字节。
字地址：4的倍数
半字地址：2的倍数
双字地址：8的倍数
字节地址：任意
那么第一个int就正好占据一个字，第一行就全是int.
short是半字，地址要是2的倍数，随意要占据第二行的前两格。
double是双字，地址要是8的倍数，第三行第一个正好是8，所以占据3，4两行。
char是字节，任意，所以占据double后面的一个格子就行了，这里正好是第五行的第一格。
short是半字，地址要是2的倍数，而char后面的那个地址是17，所以short的首地址不可以正好在char后面，要空一格，从18开始的两个格子。
边界对齐后插入数的位置如图所示：

![image.png](https://pic.rmb.bdstatic.com/bjh/fded956843ca8f2d830412e9f459b79f.jpeg)

边界对齐是以空间换时间的。
如果做题的话只要记住4B的数据(int,float)只能放在4的整数倍的地址，例如00H，04H，08H；8B(double)的数据只能放在8的整数倍的地址,例如00H，08H，10H；同理2B只能放2的整数倍；最后1B的数据可以放在任意位置<边界对齐做题目都是按字节编制的>

